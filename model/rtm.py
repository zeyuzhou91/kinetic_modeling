import numpy as npfrom scipy.optimize import curve_fitfrom scipy.signal import convolvefrom ..core import TACfrom .kineticmodel import ReferenceKineticModeldef model(reftac: TAC, R1: float, k2: float, k3: float, BPND: float):        """    reftac : reference tissue tac    R1 : K1/K1p    BPND : k3/k4    """        k4 = k3/BPND        g = k2+k3+k4    q = 4*k2*k4    p = np.sqrt(g**2-q)    r = k2/R1    c = (g+p)/2.0    d = (g-p)/2.0    a = (k3+k4-c)*(c-r)/p    b = (d-k3-k4)*(d-r)/p            t = reftac.frameschedule.mid_points        t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)        if reftac.data.shape[0] != 1:        raise ValueError("The reftac.data.shape[0] should be 1")        reftac_upsampled = np.interp(t_upsampled, t, reftac.data.flatten())        conv_upsampled = convolve(reftac_upsampled, a*np.exp(-c * t_upsampled) + b*np.exp(-d * t_upsampled), mode='full')[:len(t_upsampled)] * dt        tac_upsampled = R1 * (reftac_upsampled + conv_upsampled)        tac = np.interp(t, t_upsampled, tac_upsampled)    return tacclass RTM_Model(ReferenceKineticModel):    def __init__(self,                  reftac: TAC,                  tacs: TAC):                super().__init__(reftac, tacs)                self.micro_params = {'R1': None,                              'k2': None,                              'k3': None,                             'BPND': None}            self.macro_params = {'k4': None}                self.param_unit = {'R1': 'unitless',                           'k2': '/min',                           'k3': '/min',                           'BPND': 'unitless',                           'k4': '/min'}    def fit(self,             initial_guess: tuple | None = None):                R1_arr = np.zeros(self.tacs.num_elements)        k2_arr = np.zeros(self.tacs.num_elements)        k3_arr = np.zeros(self.tacs.num_elements)        BPND_arr = np.zeros(self.tacs.num_elements)        k4_arr = np.zeros(self.tacs.num_elements)                for i in range(self.tacs.num_elements):                                    pars, _ = curve_fit(model, self.reftac, self.tacs.data[i,:], p0 = initial_guess)                    R1, k2, k3, BPND = pars                        R1_arr[i] = R1            k2_arr[i] = k2            k3_arr[i] = k3            BPND_arr[i] = BPND                        k4_arr[i] = k3 / BPND                    self.set_parameter('R1', R1_arr, 'micro')        self.set_parameter('k2', k2_arr, 'micro')        self.set_parameter('k3', k3_arr, 'micro')        self.set_parameter('BPND', BPND_arr, 'micro')                self.set_parameter('k4', k4_arr, 'macro')                return None            def generate_fitted_tacs(self):                fitted_tacs_data = np.zeros((self.tacs.num_elements, self.tacs.frameschedule.num_frames))                    for i in range(self.tacs.num_elements):                    R1 = self.get_parameter('R1')[i]            k2 = self.get_parameter('k2')[i]            k3 = self.get_parameter('k3')[i]            BPND = self.get_parameter('BPND')[i]                                        fitted_tacs_data[i,:] = model(self.reftac, R1, k2, k3, BPND)                    self.fitted_tacs = TAC(frameschedule = self.tacs.frameschedule,                               data = fitted_tacs_data,                               rois = self.tacs.rois,                               unit = self.tacs.unit,)                        return None# import matplotlib.pyplot as plt# import numpy as np# from scipy.optimize import curve_fit# from scipy.signal import convolve# from collections.abc import Callable# from numpy.typing import NDArray# from ..core import ROI# class RTM_Model():#     def __init__(self):#         self.name = 'RTM_Model'#         self.params = {'R1': None, #                        'k2': None, #                        'k3': None,#                        'BPND': None,#                        'k4': None}        #         # The fitted function for the measured tissue activity concentration#         # Callable: np.darray -> np.darray#         # Input: reference tissue tac#         self.CT_fitted = None                  #     def print_params(self):        #         for param, value in self.params.items():#             print(f'{param} = {value}')        #         return None                        # def fit(ref: ROI, #         roi: ROI, #         t: NDArray) -> None:#     """#     ref : the reference tissue#     roi : the target tissue#     t : frame mid points. #     """            #     def model(reftac: NDArray, R1, k2, k3, BPND):#         """#         reftac : reference tissue tac#         R1 : K1/K1p#         BPND : k3/k4#         """            #         k4 = k3/BPND        #         g = k2+k3+k4#         q = 4*k2*k4#         p = np.sqrt(g**2-q)#         r = k2/R1#         c = (g+p)/2.0#         d = (g-p)/2.0#         a = (k3+k4-c)*(c-r)/p#         b = (d-k3-k4)*(d-r)/p        #         t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)        #         reftac_upsampled = np.interp(t_upsampled, t, reftac)        #         conv_upsampled = convolve(reftac_upsampled, a*np.exp(-c * t_upsampled) + b*np.exp(-d * t_upsampled), mode='full')[:len(t_upsampled)] * dt        #         tac_upsampled = R1 * (reftac_upsampled + conv_upsampled)        #         tac = np.interp(t, t_upsampled, tac_upsampled)         #         return tac        #     reftac = ref.avg_intensity #     roitac = roi.avg_intensity  # np.darray#     roi.m = RTM_Model()    #     pars, _ = curve_fit(model, reftac, roitac)#     roi.m.CT_fitted = lambda reftac: model(reftac, *pars)#     R1, k2, k3, BPND = pars    #     roi.m.params['R1'] = R1#     roi.m.params['k2'] = k2#     roi.m.params['k3'] = k3#     roi.m.params['BPND'] = BPND    #     k4 = k3 / BPND#     roi.m.params['k4'] = k4#     return None