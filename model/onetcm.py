import matplotlib.pyplot as pltimport numpy as npfrom scipy.optimize import curve_fitfrom scipy.signal import convolvefrom collections.abc import Callablefrom numpy.typing import NDArrayfrom ..core import ROIclass OneTCM_Model():    def __init__(self):        self.name = 'OneTCM_Model'        self.params = {'K1': None,                       'k2': None,                       'VB': None,                       'VD': None}                # The fitted function of time for the measured tissue activity concentration        # Callable: np.darray -> np.darray        self.CT_fitted = None             def print_params(self):                for param, value in self.params.items():            print(f'{param} = {value}')                return Nonedef fit(cp: Callable[[float], float],         roi: ROI,         t: NDArray,        cb: Callable[[float], float] | None=None,        VB_fixed: float | None=None) -> None:    """    cp : function of t. The arterial input function, the plasma activity concentration after metabolite correction.          t in [min], output in [kBq/mL]    roi : ROI object.    t : frame mid points.     cb : (optional) function of t. The whole blood activity concentration.     VB_fixed : (optional) the FIXED fraction of blood volume out of the total tissue volume     """                def model_with_VB(t, K1, k2, VB):        """        Parameters        ----------        VB : the fraction of blood volume out of the total tissue volume.         """                # t must be an array        assert type(t) == np.ndarray, "The input t must be of type numpy.ndarray"                t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)        # print(f't_upsampled: {t_upsampled}')        # print(f'dt: {dt}')                cp_upsampled = cp(t_upsampled)                # if the model has variable VB, cb cannot be None        cb_upsampled = cb(t_upsampled)                tac_upsampled = (1-VB)*convolve(cp_upsampled, K1*np.exp(-k2 * t_upsampled), mode='full')[:len(t_upsampled)] * dt + VB*cb_upsampled                tac = np.interp(t, t_upsampled, tac_upsampled)                return tac            def model_without_VB(t, K1, k2):        # Two cases:        # 1. The model does not have variable VB, nor cb        # 2. The model has cb, and fixed VB (not a variable).                # t must be an array        assert type(t) == np.ndarray, "The input t must be of type numpy.ndarray"                t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)        # print(f't_upsampled: {t_upsampled}')        # print(f'dt: {dt}')                cp_upsampled = cp(t_upsampled)                if cb == None:            cb_upsampled = np.zeros(len(t_upsampled))        else:            cb_upsampled = cb(t_upsampled)                    if VB_fixed == None: # model does not have variable VB            VB = 0        else: # model has variable VB, but it is fixed            VB = VB_fixed                tac_upsampled = (1-VB)*convolve(cp_upsampled, K1*np.exp(-k2 * t_upsampled), mode='full')[:len(t_upsampled)] * dt + VB*cb_upsampled                tac = np.interp(t, t_upsampled, tac_upsampled)                return tac        tac = roi.avg_intensity  # np.darray    roi.m = OneTCM_Model()    if (cb == None and VB_fixed == None) or (cb != None and VB_fixed != None):        # Case 1: model does not contain cb, hence nor VB        # Case 2: model contains cb, but VB is fixed        # For both cases, we need a model without VB                p0 = (1.0, 1.0)  # initial guess         pars, _ = curve_fit(model_without_VB, t, tac, p0 = p0)        roi.m.CT_fitted = lambda t: model_without_VB(t, *pars)        K1, k2 = pars        if VB_fixed != None:            VB = VB_fixed        else:             VB = 0.0            elif (cb != None and VB_fixed == None):        # Model contains cb, and VB is not fixed        # For this case, we need a model with VB                p0 = (1.0, 1.0, 0.05)  # initial guess         pars, _ = curve_fit(model_with_VB, t, tac, p0 = p0)        roi.m.CT_fitted = lambda t: model_with_VB(t, *pars)        K1, k2, VB = pars         roi.m.params['K1'] = K1    roi.m.params['k2'] = k2    roi.m.params['VB'] = VB    roi.m.params['VD'] = K1/k2            return None