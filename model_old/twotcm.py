import matplotlib.pyplot as pltimport numpy as npfrom scipy.optimize import curve_fitfrom scipy.signal import convolvefrom collections.abc import Callablefrom numpy.typing import NDArrayfrom ..core import ROIclass TwoTCM_Model():    def __init__(self):        self.name = 'TwoTCM_Model'        self.params = {'K1': None,                        'k2': None,                        'k3': None,                       'k4': None,                       'VB': None,                       'VND': None,                       'VT': None,                       'VS': None,                       'BPND': None}                # The fitted function of time for the measured tissue activity concentration        # Callable: np.darray -> np.darray        self.CT_fitted = None                      def print_params(self):                for param, value in self.params.items():            print(f'{param} = {value}')                return None                        def fit(cp: Callable[[float], float],         roi: ROI,         t: NDArray,        cb: Callable[[float], float] | None=None,        VB_fixed: float | None=None) -> None:    """    cp : function of t. The arterial input function, the plasma activity concentration after metabolite correction.          t in [min], output in [kBq/mL]    roi : ROI object.    t : frame mid points.     cb : (optional) function of t. The whole blood activity concentration.     VB_fixed : (optional) the FIXED fraction of blood volume out of the total tissue volume     """                def model_with_VB(t, K1, k2, k3, k4, VB):        """        Parameters        ----------        VB : the fraction of blood volume out of the total tissue volume.         """                        # t must be an array        assert type(t) == np.ndarray, "The input t must be of type numpy.ndarray"                g = k2+k3+k4        q = 4*k2*k4        p = np.sqrt(g**2-q)        r = K1/p        c = (g-p)/2.0        d = (g+p)/2.0        a = r*(k3+k4-c)        b = r*(d-k3-k4)                t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)        # print(f't_upsampled: {t_upsampled}')        # print(f'dt: {dt}')                cp_upsampled = cp(t_upsampled)                # if the model has variable VB, cb cannot be None        cb_upsampled = cb(t_upsampled)                tac_upsampled = (1-VB)*convolve(cp_upsampled, a*np.exp(-c * t_upsampled) + b*np.exp(-d * t_upsampled), mode='full')[:len(t_upsampled)] * dt + VB*cb_upsampled                tac = np.interp(t, t_upsampled, tac_upsampled)                return tac            def model_without_VB(t, K1, k2, k3, k4):        # Two cases:        # 1. The model does not have variable VB, nor cb        # 2. The model has cb, and fixed VB (not a variable).                # t must be an array        assert type(t) == np.ndarray, "The input t must be of type numpy.ndarray"                g = k2+k3+k4        q = 4*k2*k4        p = np.sqrt(g**2-q)        r = K1/p        c = (g-p)/2.0        d = (g+p)/2.0        a = r*(k3+k4-c)        b = r*(d-k3-k4)                t_upsampled, dt = np.linspace(np.min(t), np.max(t), 2048, retstep=True)        # print(f't_upsampled: {t_upsampled}')        # print(f'dt: {dt}')                cp_upsampled = cp(t_upsampled)                if cb == None:            cb_upsampled = np.zeros(len(t_upsampled))        else:            cb_upsampled = cb(t_upsampled)                    if VB_fixed == None: # model does not have variable VB            VB = 0        else: # model has variable VB, but it is fixed            VB = VB_fixed                tac_upsampled = (1-VB)*convolve(cp_upsampled, a*np.exp(-c * t_upsampled) + b*np.exp(-d * t_upsampled), mode='full')[:len(t_upsampled)] * dt + VB*cb_upsampled                tac = np.interp(t, t_upsampled, tac_upsampled)                return tac        tac = roi.avg_intensity  # np.darray    roi.m = TwoTCM_Model()    if (cb == None and VB_fixed == None) or (cb != None and VB_fixed != None):        # Case 1: model does not contain cb, hence nor VB        # Case 2: model contains cb, but VB is fixed        # For both cases, we need a model without VB                p0 = (1.0, 1.0, 1.0, 1.0)  # initial guess         pars, _ = curve_fit(model_without_VB, t, tac, p0 = p0)        roi.m.CT_fitted = lambda t: model_without_VB(t, *pars)        K1, k2, k3, k4 = pars        if VB_fixed != None:            VB = VB_fixed        else:             VB = 0.0            elif (cb != None and VB_fixed == None):        # Model contains cb, and VB is not fixed        # For this case, we need a model with VB                p0 = (1.0, 1.0, 1.0, 1.0, 0.05)  # initial guess         pars, _ = curve_fit(model_with_VB, t, tac, p0 = p0)        roi.m.CT_fitted = lambda t: model_with_VB(t, *pars)        K1, k2, k3, k4, VB = pars         roi.m.params['K1'] = K1    roi.m.params['k2'] = k2    roi.m.params['k3'] = k3    roi.m.params['k4'] = k4    roi.m.params['VB'] = VB    roi.m.params['VND'] = K1/k2    roi.m.params['VS'] = K1*k3/(k2*k4)    roi.m.params['VT'] = K1/k2*(1+k3/k4)    roi.m.params['BPND'] = k3/k4            return None